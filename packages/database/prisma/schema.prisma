generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum ClientType {
  particulier
  professionnel
  syndic
}

enum UserRole {
  patron
  employe
}

enum ChantierStatut {
  lead
  visite_planifiee
  devis_envoye
  accepte
  planifie
  en_cours
  termine
  facture
  annule
}

enum TypePrestation {
  paysagisme
  entretien
  elagage
  abattage
  tonte
  taille
  autre
}

enum DevisStatut {
  brouillon
  envoye
  signe
  accepte
  refuse
  expire
}

enum FactureStatut {
  brouillon
  envoyee
  payee
  annulee
}

enum ModePaiement {
  virement
  cheque
  especes
  carte
}

enum AbsenceType {
  conge
  maladie
  formation
  autre
}

// ============================================
// MODELS
// ============================================

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  passwordHash      String
  nom               String
  prenom            String
  telephone         String?
  role              UserRole  @default(employe)
  actif             Boolean   @default(true)
  avatarUrl         String?
  icalToken         String?   @unique
  derniereConnexion DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // 2FA
  twoFactorSecret   String?   // TOTP secret (chiffré AES-256)
  twoFactorEnabled  Boolean   @default(false)
  recoveryCodes     String[]  // Codes de récupération (hashés bcrypt)
  twoFactorAttempts Int       @default(0) // Compteur tentatives échouées
  twoFactorLockedUntil DateTime? // Verrouillage après 5 tentatives

  // Relations
  chantiersResponsable Chantier[]     @relation("ChantierResponsable")
  interventions        Intervention[]
  auditLogs            AuditLog[]
  pushSubscriptions    PushSubscription[]
  absences             Absence[]
  knownDevices         KnownDevice[]
  refreshTokens        RefreshToken[]
  notifications        Notification[]

  @@map("users")
}

model Client {
  id                   String     @id @default(uuid())
  type                 ClientType
  nom                  String
  prenom               String?
  raisonSociale        String?
  email                String
  telephone            String
  telephoneSecondaire  String?
  adresse              String
  codePostal           String
  ville                String
  notes                String?
  tags                 String[]
  excludeRelance       Boolean    @default(false) // Client VIP, exclure des relances auto
  deletedAt            DateTime?  // Soft delete
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  // Relations
  chantiers     Chantier[]
  authTokens    ClientAuthToken[]
  conversations Conversation[]

  @@index([type])
  @@index([ville])
  @@index([email])
  @@index([deletedAt])
  @@map("clients")
}

model ClientAuthToken {
  id        String   @id @default(uuid())
  clientId  String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  // Relations
  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([token])
  @@index([expiresAt])
  @@map("client_auth_tokens")
}

model Chantier {
  id              String          @id @default(uuid())
  clientId        String
  adresse         String
  codePostal      String
  ville           String
  latitude        Float?
  longitude       Float?
  typePrestation  TypePrestation[]
  description     String
  surface         Float?
  statut          ChantierStatut  @default(lead)
  dateVisite      DateTime?
  dateDebut       DateTime?
  dateFin         DateTime?
  responsableId   String?
  notes           String?
  photos          String[]
  deletedAt       DateTime?       // Soft delete
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  client        Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  responsable   User?          @relation("ChantierResponsable", fields: [responsableId], references: [id])
  devis         Devis[]
  interventions Intervention[]
  conversations Conversation[]

  @@index([clientId])
  @@index([statut])
  @@index([responsableId])
  @@index([dateDebut])
  @@index([deletedAt])
  @@map("chantiers")
}

model Devis {
  id                    String      @id @default(uuid())
  chantierId            String
  numero                String      @unique
  dateEmission          DateTime    @default(now())
  dateValidite          DateTime
  totalHT               Float
  totalTVA              Float
  totalTTC              Float
  statut                DevisStatut @default(brouillon)
  dateAcceptation       DateTime?
  signatureClient       String?
  pdfUrl                String?
  conditionsParticulieres String?
  notes                 String?
  deletedAt             DateTime?   // Soft delete
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt

  // Relations
  chantier   Chantier        @relation(fields: [chantierId], references: [id], onDelete: Cascade)
  lignes     LigneDevis[]
  factures   Facture[]
  signature  SignatureDevis?

  @@index([chantierId])
  @@index([statut])
  @@index([numero])
  @@index([deletedAt])
  @@map("devis")
}

model SignatureDevis {
  id            String   @id @default(uuid())
  devisId       String   @unique
  token         String   @unique
  imageBase64   String   @db.Text
  signedAt      DateTime @default(now())
  expiresAt     DateTime
  ipAddress     String
  userAgent     String
  cgvAccepted   Boolean  @default(true)
  createdAt     DateTime @default(now())

  // Relations
  devis Devis @relation(fields: [devisId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([devisId])
  @@map("signatures_devis")
}

model LigneDevis {
  id             String @id @default(uuid())
  devisId        String
  description    String
  quantite       Float
  unite          String
  prixUnitaireHT Float
  tva            Float  @default(20)
  montantHT      Float
  montantTTC     Float
  ordre          Int    @default(0)

  // Relations
  devis Devis @relation(fields: [devisId], references: [id], onDelete: Cascade)

  @@index([devisId])
  @@map("lignes_devis")
}

model Facture {
  id                String        @id @default(uuid())
  devisId           String
  numero            String        @unique
  dateEmission      DateTime      @default(now())
  dateEcheance      DateTime
  datePaiement      DateTime?
  totalHT           Float
  totalTVA          Float
  totalTTC          Float
  statut            FactureStatut @default(brouillon)
  modePaiement      ModePaiement?
  referencePaiement String?
  pdfUrl            String?
  mentionsLegales   String?
  notes             String?
  excludeRelance    Boolean       @default(false) // Exclure des relances auto (litige, accord special)
  deletedAt         DateTime?     // Soft delete
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  devis    Devis            @relation(fields: [devisId], references: [id])
  lignes   LigneFacture[]
  relances RelanceHistory[]

  @@index([devisId])
  @@index([statut])
  @@index([numero])
  @@index([dateEcheance])
  @@index([deletedAt])
  @@map("factures")
}

model LigneFacture {
  id             String @id @default(uuid())
  factureId      String
  description    String
  quantite       Float
  unite          String
  prixUnitaireHT Float
  tva            Float
  montantHT      Float
  montantTTC     Float
  ordre          Int    @default(0)

  // Relations
  facture Facture @relation(fields: [factureId], references: [id], onDelete: Cascade)

  @@index([factureId])
  @@map("lignes_factures")
}

model Intervention {
  id          String   @id @default(uuid())
  chantierId  String
  employeId   String
  date        DateTime
  heureDebut  DateTime
  heureFin    DateTime?
  dureeMinutes Int?
  description String?
  photos      String[]
  notes       String?
  valide      Boolean  @default(false)
  deletedAt   DateTime? // Soft delete
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  chantier Chantier @relation(fields: [chantierId], references: [id], onDelete: Cascade)
  employe  User     @relation(fields: [employeId], references: [id])

  @@index([chantierId])
  @@index([employeId])
  @@index([date])
  @@index([deletedAt])
  @@map("interventions")
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?
  action     String
  entite     String
  entiteId   String?
  details    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([entite])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// PUSH NOTIFICATIONS
// ============================================

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String   // Public key for encryption
  auth      String   // Auth secret
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

// ============================================
// ABSENCES / DISPONIBILITES
// ============================================

model Absence {
  id        String      @id @default(uuid())
  userId    String
  dateDebut DateTime
  dateFin   DateTime
  type      AbsenceType
  motif     String?
  validee   Boolean     @default(false)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([dateDebut, dateFin])
  @@map("absences")
}

// ============================================
// MESSAGERIE CLIENT
// ============================================

enum SenderType {
  client
  entreprise
}

model Conversation {
  id          String    @id @default(uuid())
  clientId    String
  chantierId  String?
  subject     String
  lastMessageAt DateTime @default(now())
  unreadByClient Boolean @default(false)
  unreadByAdmin  Boolean @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  client    Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  chantier  Chantier?  @relation(fields: [chantierId], references: [id])
  messages  Message[]

  @@index([clientId])
  @@index([chantierId])
  @@index([lastMessageAt])
  @@map("conversations")
}

model Message {
  id              String     @id @default(uuid())
  conversationId  String
  senderType      SenderType
  senderId        String?
  content         String
  attachments     String[]
  readAt          DateTime?
  createdAt       DateTime   @default(now())

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

// ============================================
// DEVICE TRACKING (Securite connexions)
// ============================================

model KnownDevice {
  id            String    @id @default(uuid())
  userId        String
  fingerprint   String    // SHA256(User-Agent + Accept-Language)
  deviceName    String?   // Nom derive du User-Agent (ex: "Chrome sur Windows")
  lastIp        String?
  lastCountry   String?
  lastCity      String?
  firstSeenAt   DateTime  @default(now())
  lastSeenAt    DateTime  @default(now())
  trustedAt     DateTime? // null = pas encore valide par l'utilisateur
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshTokens RefreshToken[]

  @@unique([userId, fingerprint])
  @@index([userId])
  @@index([fingerprint])
  @@map("known_devices")
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  token     String    @unique
  deviceId  String?   // Lien vers KnownDevice
  familyId  String    // Groupe de tokens lies (pour rotation)
  usedAt    DateTime? // Marque quand le token a ete utilise
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  // Relations
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  device KnownDevice? @relation(fields: [deviceId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([token])
  @@index([deviceId])
  @@index([familyId])
  @@map("refresh_tokens")
}

// ============================================
// SEQUENCES (pour numeros devis/factures)
// ============================================

model Sequence {
  id       String @id
  prefix   String
  year     Int
  lastValue Int   @default(0)

  @@unique([prefix, year])
  @@map("sequences")
}

// ============================================
// PHASE 9 - ZERO PERTE / RESILIENCE
// ============================================

enum EmailStatus {
  pending
  sent
  failed
  bounced
}

enum DocumentType {
  devis
  devis_signe
  facture
  relance
}

enum RelanceLevel {
  rappel_amical      // J+30 - Premier rappel
  rappel_ferme       // J+45 - Deuxieme rappel
  mise_en_demeure    // J+60 - Mise en demeure
}

enum NotificationType {
  info
  warning
  success
  action_required
}

model EmailHistory {
  id            String      @id @default(uuid())
  to            String
  cc            String?
  bcc           String?
  subject       String
  templateName  String?
  status        EmailStatus @default(pending)
  messageId     String?
  errorMessage  String?
  documentType  DocumentType?
  documentId    String?
  attachments   String[]
  metadata      Json?
  sentAt        DateTime?
  createdAt     DateTime    @default(now())

  @@index([to])
  @@index([status])
  @@index([documentId])
  @@index([createdAt])
  @@map("email_history")
}

model DocumentArchive {
  id            String       @id @default(uuid())
  documentType  DocumentType
  documentId    String
  documentNumero String
  s3Key         String
  s3Bucket      String
  fileName      String
  fileSize      Int
  mimeType      String       @default("application/pdf")
  checksum      String?
  archivedAt    DateTime     @default(now())
  metadata      Json?

  @@index([documentType])
  @@index([documentId])
  @@index([documentNumero])
  @@index([archivedAt])
  @@map("document_archives")
}

model BackupHistory {
  id          String   @id @default(uuid())
  fileName    String
  s3Key       String
  s3Bucket    String
  fileSize    Int
  durationMs  Int
  status      String   @default("success")
  errorMessage String?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@map("backup_history")
}

// ============================================
// RELANCES AUTOMATIQUES FACTURES IMPAYEES
// ============================================

model RelanceHistory {
  id            String       @id @default(uuid())
  factureId     String
  level         RelanceLevel
  sentAt        DateTime     @default(now())
  emailId       String?      // Lien vers EmailHistory
  joursRetard   Int          // Nombre de jours de retard au moment de l'envoi
  montantDu     Float        // Montant restant du au moment de la relance
  success       Boolean      @default(true)
  errorMessage  String?
  createdAt     DateTime     @default(now())

  // Relations
  facture Facture @relation(fields: [factureId], references: [id], onDelete: Cascade)

  @@index([factureId])
  @@index([level])
  @@index([sentAt])
  @@map("relance_history")
}

// ============================================
// NOTIFICATIONS IN-APP
// ============================================

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType @default(info)
  title     String
  message   String
  link      String?          // Ex: /devis/123, /factures/456
  readAt    DateTime?
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([userId, createdAt])
  @@map("notifications")
}
